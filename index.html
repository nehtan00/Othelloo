<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Google Sans', sans-serif;
            background-color: #f0e6d2;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column; /* Stack the selection and game */
        }

        .selection-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .selection-container h2 {
            color: #5e503f;
            margin-bottom: 15px;
        }

        .selection-container button, .difficulty-container button {
            font-family: 'Google Sans', sans-serif;
            background-color: #c6b8a9;
            color: #5e503f;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease-in-out;
            margin: 5px;
        }

        .selection-container button:hover, .difficulty-container button:hover {
            background-color: #b0a194;
        }

        .difficulty-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .difficulty-container h3 {
            color: #5e503f;
            margin-bottom: 10px;
        }

        .container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background-color: #776e65;
            border-radius: 4px;
        }

        .cell {
            background-color: #c6b8a9;
            width: 60px;
            height: 60px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .cell:hover {
            filter: brightness(1.1);
        }

        .piece {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
        }

        .piece.black {
            background-color: #333;
        }

        .piece.white {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
        }

        .cell.possible-move {
            background-color: #b0a194;
        }

        .cell.possible-move::before {
            content: '';
            display: block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: rgba(51, 51, 51, 0.6);
        }

        .cell.possible-move.white::before {
            background-color: rgba(249, 249, 249, 0.6);
            border: 1px solid rgba(204, 204, 204, 0.6);
        }

        .info {
            margin-top: 20px;
            text-align: center;
            color: #5e503f;
        }

        .info p {
            margin: 5px 0;
        }

        .info button {
            font-family: 'Google Sans', sans-serif;
            background-color: #c6b8a9;
            color: #5e503f;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease-in-out;
        }

        .info button:hover {
            background-color: #b0a194;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="selection-container" id="game-mode-selection">
        <h2>Choose Game Mode</h2>
        <button onclick="startGame('pvp')">Player vs Player</button>
        <button onclick="showDifficultySelection()">Player vs Computer</button>
    </div>

    <div class="difficulty-container hidden" id="difficulty-selection">
        <h3>Choose Difficulty</h3>
        <button onclick="startGame('pvc', 'easy')">Easy</button>
        <button onclick="startGame('pvc', 'medium')">Medium</button>
        <button onclick="startGame('pvc', 'hard')">Hard</button>
    </div>

    <div class="container hidden" id="game-container">
        <div class="board" id="othello-board">
        </div>
        <div class="info">
            <p id="turn"></p>
            <p id="score"></p>
            <button onclick="resetGame()">Reset Game</button>
        </div>
    </div>

    <script>
        const gameModeSelection = document.getElementById('game-mode-selection');
        const difficultySelection = document.getElementById('difficulty-selection');
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('othello-board');
        const turnElement = document.getElementById('turn');
        const scoreElement = document.getElementById('score');
        let board = Array(8).fill(null).map(() => Array(8).fill(null));
        let currentPlayer = 'black';
        let possibleMoves = [];
        let gameMode = null;
        let computerDifficulty = null;

        function showDifficultySelection() {
            gameModeSelection.classList.add('hidden');
            difficultySelection.classList.remove('hidden');
        }

        function startGame(mode, difficulty) {
            gameMode = mode;
            computerDifficulty = difficulty;
            gameModeSelection.classList.add('hidden');
            difficultySelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            resetGame();
        }

        function initializeBoard() {
            board[3][3] = 'white';
            board[4][4] = 'white';
            board[3][4] = 'black';
            board[4][3] = 'black';
        }

        function createBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', handleMove);

                    const piece = board[i][j];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', piece);
                        cell.appendChild(pieceElement);
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        function updateBoardDisplay() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.innerHTML = '';

                const piece = board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('piece', piece);
                    cell.appendChild(pieceElement);
                }
                cell.classList.remove('possible-move', 'white');
                if (possibleMoves.some(move => move.row === row && move.col === col)) {
                    cell.classList.add('possible-move');
                    if (currentPlayer === 'white') {
                        cell.classList.add('white');
                    }
                }
            });
        }

        function updateTurnDisplay() {
            turnElement.textContent = `${currentPlayer === 'black' ? 'Black' : 'White'}'s Turn`;
        }

        function updateScoreDisplay() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }
            scoreElement.textContent = `Black: ${blackCount}, White: ${whiteCount}`;
        }

        function getOpponent(player) {
            return player === 'black' ? 'white' : 'black';
        }

        function isValidMove(row, col, player) {
            if (row < 0 || row > 7 || col < 0 || col > 7 || board[row][col]) {
                return false;
            }

            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    foundOpponent = true;
                    r += dr;
                    c += dc;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
                    return true;
                }
            }

            return false;
        }

        function getPossibleMoves(player) {
            const moves = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (isValidMove(i, j, player)) {
                        moves.push({ row: i, col: j });
                    }
                }
            }
            return moves;
        }

        function flipPieces(row, col, player) {
            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const piecesToFlip = [];
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    foundOpponent = true;
                    piecesToFlip.push({ row: r, col: c });
                    r += dr;
                    c += dc;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
                    piecesToFlip.forEach(p => {
                        board[p.row][p.col] = player;
                    });
                }
            }
        }

        function handleMove(event) {
            const cell = event.target.closest('.cell');
            if (!cell || !cell.classList.contains('possible-move')) {
                return;
            }

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            board[row][col] = currentPlayer;
            flipPieces(row, col, currentPlayer);
            updateBoardDisplay();

            currentPlayer = getOpponent(currentPlayer);
            possibleMoves = getPossibleMoves(currentPlayer);

            if (possibleMoves.length === 0) {
                const opponentMoves = getPossibleMoves(currentPlayer);
                if (opponentMoves.length === 0) {
                    endGame();
                    return;
                } else {
                    currentPlayer = getOpponent(currentPlayer);
                    possibleMoves = getPossibleMoves(currentPlayer);
                    updateTurnDisplay();
                    updateBoardDisplay(); // To show possible moves for the new player
                    alert(`${currentPlayer === 'black' ? 'Black' : 'White'} has no moves and skips their turn.`);
                    if (gameMode === 'pvc' && currentPlayer === 'white') {
                        setTimeout(computerMove, 1000); // Computer takes turn after skip
                    }
                    return;
                }
            }

            updateTurnDisplay();
            updateScoreDisplay();
            updateBoardDisplay(); // To show the new possible moves

            if (gameMode === 'pvc' && currentPlayer === 'white') {
                setTimeout(computerMove, 1000);
            }
        }

        function endGame() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }

            let winner = '';
            if (blackCount > whiteCount) {
                winner = 'Black';
            } else if (whiteCount > blackCount) {
                winner = 'White';
            } else {
                winner = 'It\'s a Draw!';
            }

            alert(`Game Over! Black: ${blackCount}, White: ${whiteCount}. Winner: ${winner}`);
        }

        function resetGame() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            currentPlayer = 'black';
            initializeBoard();
            updateBoardDisplay();
            updateTurnDisplay();
            updateScoreDisplay();
            possibleMoves = getPossibleMoves(currentPlayer);
            updateBoardDisplay(); // To highlight initial possible moves
            if (gameMode === 'pvc' && currentPlayer === 'white') {
                setTimeout(computerMove, 1000);
            }
        }

        function computerMove() {
            if (gameMode !== 'pvc' || currentPlayer !== 'white') {
                return;
            }

            const possibleComputerMoves = getPossibleMoves('white');
            if (possibleComputerMoves.length > 0) {
                let bestMove;

                switch (computerDifficulty) {
                    case 'easy':
                        bestMove = possibleComputerMoves[Math.floor(Math.random() * possibleComputerMoves.length)];
                        break;
                    case 'medium':
                        // Basic strategy: prioritize corners, then moves that flip more pieces
                        bestMove = findBestMove(possibleComputerMoves);
                        break;
                    case 'hard':
                        // More advanced strategy (can be improved further): minimax with a limited depth
                        bestMove = findBestMoveMinimax(board, 'white', 3); // Depth of 3 for example
