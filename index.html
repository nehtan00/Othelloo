<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Multiplayer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Google Sans', sans-serif;
            background-color: #f0e6d2; /* Light earthy background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column; /* Stack the selection and game */
        }

        .auth-status {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: #e0c8a9;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #5e503f;
            z-index: 100;
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center; /* Center horizontally */
            align-items: center;   /* Center vertically */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto; /* Center horizontally and vertically */
            padding: 30px;
            border: 1px solid #888;
            width: 60%; /* Responsive width */
            max-width: 400px; /* Max width for larger screens */
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            color: #5e503f; /* Earthy text color */
            font-size: 1.2em;
        }

        .modal-content h3 {
            margin-top: 0;
            color: #333;
            font-weight: 700;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .selection-container {
            background-color: #a08e79; /* Medium earthy tone */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .selection-container h2 {
            color: #5e503f; /* Earthy text color */
            margin-bottom: 15px;
        }

        .selection-container button, .difficulty-container button, .info button,
        .lobby-controls button {
            font-family: 'Google Sans', sans-serif;
            background-color: #c6b8a9; /* Lighter earthy tone */
            color: #5e503f; /* Earthy text color */
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            margin: 5px;
            outline: none; /* Remove outline on focus */
        }

        .selection-container button:hover, .difficulty-container button:hover, .info button:hover,
        .lobby-controls button:hover {
            background-color: #b0a194; /* Slightly darker hover */
            transform: translateY(-2px); /* Subtle lift on hover */
        }
        .selection-container button:active, .difficulty-container button:active, .info button:active,
        .lobby-controls button:active {
            transform: translateY(0); /* Press down on click */
        }

        .lobby-controls button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .difficulty-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .difficulty-container h3 {
            color: #5e503f;
            margin-bottom: 10px;
        }

        .lobby-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .lobby-container h2, .lobby-container h3 {
            color: #5e503f;
        }

        .lobby-controls input[type="text"] {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #776e65;
            margin-right: 10px;
            font-family: 'Google Sans', sans-serif;
            font-size: 16px;
            background-color: #f9f9f9;
            color: #333;
        }

        .available-games-list {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #776e65;
            border-radius: 5px;
            background-color: #e0c8a9;
            padding: 10px;
        }
        .available-games-list button {
            display: block;
            width: calc(100% - 10px);
            margin: 5px auto;
            text-align: center;
            padding: 8px;
            background-color: #c6b8a9;
            color: #5e503f;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .available-games-list button:hover {
            background-color: #b0a194;
        }

        .current-game-info {
            margin-top: 20px;
            color: #5e503f;
            font-size: 1.1em;
        }


        .container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background-color: #776e65; /* Darker earthy tone for grid lines */
            border-radius: 4px;
        }

        .cell {
            background-color: #c6b8a9; /* Lighter earthy tone for cells */
            width: 60px;
            height: 60px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .cell:hover {
            filter: brightness(1.1);
        }

        .piece {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
        }

        .piece.black {
            background-color: #333;
        }

        .piece.white {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
        }

        /* Styles for a piece that is in a corner position */
        .piece.corner-locked {
            position: relative;
            background-color: transparent !important; /* Hide the background color of the piece itself */
            box-shadow: none !important; /* Remove shadow to make icon prominent */
            border: none !important; /* Remove border */
            display: flex; /* Use flex to center the icon */
            justify-content: center;
            align-items: center;
            font-size: 2.2em; /* Adjust size of the icon */
            color: #333; /* Default color for black castles */
        }

        .piece.corner-locked.white {
            color: #f9f9f9; /* Color for white castles */
        }

        .piece.corner-locked::before {
            font-family: "Font Awesome 6 Free"; /* Specify Font Awesome font */
            font-weight: 900; /* Solid icon weight */
            content: "\f447"; /* Unicode for fa-chess-rook icon */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* Add shadow to the icon itself */
        }

        .cell.possible-move {
            background-color: #b0a194; /* Slightly darker hover for possible moves */
        }

        .cell.possible-move::before {
            content: '';
            display: block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: rgba(51, 51, 51, 0.6); /* Indicate possible black move */
            transition: background-color 0.2s ease-in-out;
        }

        .cell.possible-move.white::before {
            background-color: rgba(249, 249, 249, 0.6); /* Indicate possible white move */
            border: 1px solid rgba(204, 204, 204, 0.6);
        }

        .info {
            margin-top: 20px;
            text-align: center;
            color: #5e503f; /* Earthy text color */
        }

        .info p {
            margin: 5px 0;
        }

        .rules-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin-top: 20px;
            width: 90%; /* Use a percentage for responsiveness */
            max-width: 520px; /* Max width for larger screens, matching board */
            text-align: center;
            color: #5e503f;
            box-sizing: border-box; /* Include padding in the width */
        }

        .rules-container h3 {
            color: #5e503f;
            margin-bottom: 10px;
        }

        .rules-toggle {
            width: auto;
            padding: 10px 20px;
            margin-bottom: 15px; /* Space between button and content */
        }

        .rules-content {
            max-height: 0;
            overflow-y: auto; /* Make content scrollable if it overflows vertically */
            transition: max-height 0.5s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 0;
            text-align: left; /* Align content within */
            padding: 0 15px; /* Add more padding to ensure text isn't cut off at edges */
            box-sizing: border-box; /* Include padding in the max-height */
        }

        .rules-content.expanded {
            max-height: 500px; /* Arbitrary large value to allow content to expand and scroll */
            opacity: 1;
            padding-bottom: 15px; /* Add padding when expanded */
        }

        .rules-content ul, .rules-content ol {
            list-style: decimal; /* Use numbered list for rules */
            padding-left: 20px; /* Indent list items */
            text-align: left;
            margin: 0; /* Remove default ul/ol margins */
            /* No max-width here to allow text to wrap within the container's padding */
        }
        .rules-content ul {
            list-style: disc; /* Use bullet points for tips */
        }


        .rules-content li {
            margin-bottom: 8px;
            line-height: 1.4;
            word-wrap: break-word; /* Ensure long words break to fit */
        }

        .rules-content b {
            font-weight: 700;
            color: #333;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="auth-status" id="auth-status">Authenticating...</div>

    <div class="modal" id="winner-modal">
        <div class="modal-content">
            <span class="close-button" onclick="window.closeWinnerModal()">&times;</span>
            <p id="winner-message"></p>
            <h3>Final Scores:</h3>
            <p id="final-scores"></p>
        </div>
    </div>

    <div class="selection-container hidden" id="initial-setup">
        <h2>Choose Game Type</h2>
        <button onclick="window.showMultiplayerLobby()">Multiplayer</button>
        <button onclick="window.showDifficultySelection()">Single Player (vs Computer)</button>
    </div>

    <div class="lobby-container hidden" id="multiplayer-lobby">
        <h2>Multiplayer Lobby</h2>
        <div class="lobby-controls">
            <input type="text" id="game-id-input" placeholder="Enter Game ID">
            <button id="create-game-button" onclick="window.createGame()" disabled>Create Game</button>
            <button id="join-game-button" onclick="window.joinGame()" disabled>Join Game</button>
        </div>
        <div class="available-games-list">
            <h3>Available Games:</h3>
            <div id="available-games">Loading games...</div>
            <button id="refresh-games-button" onclick="window.refreshAvailableGames()" disabled>Refresh List</button>
        </div>
        <div class="current-game-info hidden" id="current-game-info">
            <p>Game ID: <span id="display-game-id"></span></p>
            <p>Your Color: <span id="your-color"></span></p>
            <button onclick="window.leaveGame()">Leave Lobby</button>
            <button onclick="window.copyGameLink()">Copy Game Link</button>
        </div>
    </div>

    <div class="difficulty-container hidden" id="difficulty-selection">
        <h3>Choose Difficulty</h3>
        <button onclick="window.startGame('pvc', 'easy')">Easy</button>
        <button onclick="window.startGame('pvc', 'medium')">Medium</button>
        <button onclick="window.startGame('pvc', 'hard')">Hard</button>
    </div>

    <div class="container hidden" id="game-container">
        <div class="board" id="othello-board">
            </div>
        <div class="info">
            <p id="turn">Black's Turn</p>
            <p id="score">Black: 2, White: 2</p>
            <p>Game ID: <span id="game-display-id-in-game"></span></p> <button onclick="window.resetGame()">Reset Game</button>
            <button onclick="window.leaveGameFromInGame()">Back to Lobby</button> </div>
    </div>

    <div class="rules-container">
        <button class="rules-toggle" onclick="window.toggleRules()">Show Rules & Tips</button>
        <div class="rules-content" id="rules-tips-content">
            <h3>Othello Rules</h3>
            <ol>
                <li>The game is played on an 8x8 board with two players, Black and White.</li>
                <li>It starts with two black and two white pieces in the four central squares, with same-colored pieces on diagonals.</li>
                <li>Players take turns placing one piece of their color on a vacant square.</li>
                <li>A piece must be placed such that it "sandwiches" one or more of the opponent's pieces horizontally, vertically, or diagonally, between the newly placed piece and an existing piece of the current player's color.</li>
                <li>All sandwiched opponent's pieces are immediately flipped to the current player's color. You must flip at least one piece to make a valid move.</li>
                <li>If a player cannot make a valid move, they must pass their turn. The other player continues playing until a valid move is possible.</li>
                <li>The game ends when neither player can make a valid move, or when the board is completely full (64 pieces).</li>
                <li>The player with the most pieces on the board at the end of the game wins. If counts are equal, it's a draw.</li>
            </ol>
            <h3>Tips for Beginners</h3>
            <ul>
                <li><b>Corners are King:</b> Once you place a piece in a corner, it can never be flipped. Prioritize capturing corners whenever possible. This is a powerful advantage!</li>
                <li><b>Avoid Edges (Mostly):</b> Pieces on the edges can become stable (unflippable) if you control enough of them. However, be careful with squares directly next to corners on the edges (often called "X-squares" or "C-squares"), as these can often give your opponent access to the corner.</li>
                <li><b>Mobility is Key:</b> The player with more available valid moves often has an advantage. Try to limit your opponent's choices while expanding your own.</li>
                <li><b>Don't Flip Too Many (Early):</b> Sometimes, flipping a large number of pieces early in the game can be detrimental if it opens up strong positions (like corners) for your opponent. Focus on strategic placement over just maximizing flips.</li>
                <li><b>Think Ahead:</b> Othello is a game of foresight. Try to visualize the board a few moves into the future to anticipate your opponent's strategy and plan your own.</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";

        // Your Firebase configuration (provided by the user)
        const firebaseConfig = {
          apiKey: "AIzaSyAUA91LXtcccAxl9OADnsYQwy1NPqjQgCA",
          authDomain: "othelloo-f8fac.firebaseapp.com",
          projectId: "othelloo-f8fac",
          storageBucket: "othelloo-f8fac.firebasestorage.app",
          messagingSenderId: "918267777112",
          appId: "1:918267777112:web:2c14924573793129573a2d",
          measurementId: "G-5RVK6DT5W0"
        };

        // Determine the appId to be used for Firestore paths.
        const appId = firebaseConfig.projectId; // Using projectId as the application ID for Firestore paths

        // Initialize Firebase app
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        setLogLevel('Debug'); // Enable Firestore debug logging for console output


        // Get references to DOM elements
        const initialSetup = document.getElementById('initial-setup');
        const multiplayerLobby = document.getElementById('multiplayer-lobby');
        const difficultySelection = document.getElementById('difficulty-selection');
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('othello-board');
        const turnElement = document.getElementById('turn');
        const scoreElement = document.getElementById('score');
        const winnerModal = document.getElementById('winner-modal');
        const winnerMessage = document.getElementById('winner-message');
        const finalScoresElement = document.getElementById('final-scores');
        const gameIdInput = document.getElementById('game-id-input');
        const availableGamesDiv = document.getElementById('available-games');
        const currentGameInfo = document.getElementById('current-game-info');
        const displayGameId = document.getElementById('display-game-id'); // For lobby
        const yourColorElement = document.getElementById('your-color');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const refreshGamesButton = document.getElementById('refresh-games-button');
        const gameDisplayIdInGame = document.getElementById('game-display-id-in-game'); // For in-game display
        const rulesContent = document.getElementById('rules-tips-content');
        const rulesToggleButton = document.querySelector('.rules-toggle');


        // Game state variables
        let board = Array(8).fill(null).map(() => Array(8).fill(null));
        let currentPlayer = 'black';
        let possibleMoves = [];
        let gameMode = null; // 'pvp', 'pvc', 'multiplayer'
        let computerDifficulty = null; // 'easy', 'medium', 'hard'
        let playerColor = null; // 'black' or 'white' for the current user in multiplayer
        let currentGameId = null; // The ID of the current multiplayer game
        let unsubscribeFromGame = null; // Function to unsubscribe from Firestore listener

        // Flag to ensure board HTML is rendered only once
        let boardHtmlRendered = false;


        // --- Firebase Anonymous Authentication and UI state management ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log("Firebase authenticated:", user.uid);
                document.getElementById('auth-status').textContent = `Authenticated: ${user.uid.substring(0, 8)}...`;
                // Enable multiplayer buttons once authenticated
                if (createGameButton) createGameButton.disabled = false;
                if (joinGameButton) joinGameButton.disabled = false;
                if (refreshGamesButton) refreshGamesButton.disabled = false;

                // Check if a game ID is in the URL to auto-join
                const urlParams = new URLSearchParams(window.location.search);
                const gameIdFromUrl = urlParams.get('gameId');
                if (gameIdFromUrl) {
                    gameIdInput.value = gameIdFromUrl; // Pre-fill input
                    window.joinGameFromUrl(gameIdFromUrl); // Call global function
                } else {
                    // If no gameId in URL, show the initial game type selection
                    initialSetup.classList.remove('hidden');
                }
            } else {
                console.log("Firebase not authenticated. Signing in anonymously...");
                // Disable multiplayer buttons if not authenticated
                if (createGameButton) createGameButton.disabled = true;
                if (joinGameButton) joinGameButton.disabled = true;
                if (refreshGamesButton) refreshGamesButton.disabled = true;

                document.getElementById('auth-status').textContent = `Authenticating...`;
                signInAnonymously(auth).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                    document.getElementById('auth-status').textContent = `Authentication failed: ${error.message}. Please refresh the page.`;
                });
            }
        });


        // --- Firebase Interaction Functions (remain internal to module) ---
        async function createFirebaseGame(gameId, player1Uid) {
            console.log("createFirebaseGame: Attempting to create document for gameId:", gameId, "by UID:", player1Uid);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const initialBoard = Array(8).fill(null).map(() => Array(8).fill(null));

            // Set initial pieces on the board
            initialBoard[3][3] = 'white';
            initialBoard[4][4] = 'white';
            initialBoard[3][4] = 'black';
            initialBoard[4][3] = 'black';

            const gameData = {
                gameId: gameId,
                players: [{uid: player1Uid, color: 'black'}], // Creator is Player 1 (Black)
                board: JSON.stringify(initialBoard), // Store 2D array as JSON string
                currentPlayer: 'black',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                lastMoveTimestamp: Date.now()
            };
            try {
                await setDoc(gameRef, gameData);
                console.log("createFirebaseGame: Document successfully written!");
                return { success: true, message: "Game created successfully." }; // Return success message
            } catch (e) {
                console.error("createFirebaseGame: Error writing document:", e);
                return { success: false, message: e.message || "Unknown error during game creation." }; // Return failure message
            }
        }

        async function joinFirebaseGame(gameId, player2Uid) {
            console.log("joinFirebaseGame: Attempting to join gameId:", gameId, "by UID:", player2Uid);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const gameSnap = await getDoc(gameRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                // Check if there's only one player and it's not the joining player
                if (gameData.players.length === 1 && gameData.players[0].uid !== player2Uid) {
                    try {
                        await updateDoc(gameRef, {
                            players: arrayUnion({uid: player2Uid, color: 'white'}), // Add Player 2 (White)
                            status: 'playing' // Change game status to playing
                        });
                        console.log("joinFirebaseGame: Game successfully joined in Firestore:", gameId);
                        return { success: true, message: "Game joined successfully." }; // Return success
                    } catch (e) {
                        console.error("joinFirebaseGame: Error updating document for join:", e);
                        return { success: false, message: e.message || "Permission denied or other update error." }; // Return error message
                    }
                } else if (gameData.players.some(p => p.uid === player2Uid)) {
                     console.log("joinFirebaseGame: Rejoining existing game:", gameId);
                     return { success: true, message: "Rejoining existing game." }; // Already in the game, just rejoining
                } else if (gameData.players.length === 2) {
                    return { success: false, message: "This game is already full." }; // Game is already full
                }
            } else {
                return { success: false, message: "Game ID does not exist." }; // Game ID does not exist
            }
        }

        async function updateFirebaseBoard(gameId, newBoard, nextPlayer, newStatus) {
            console.log("updateFirebaseBoard: Updating gameId:", gameId, "to status:", newStatus);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            try {
                // Convert 2D array to JSON string for Firestore storage
                await updateDoc(gameRef, {
                    board: JSON.stringify(newBoard), // Store as JSON string
                    currentPlayer: nextPlayer,
                    status: newStatus,
                    lastMoveTimestamp: Date.now()
                });
                console.log("updateFirebaseBoard: Game state successfully updated in Firestore.");
                return { success: true, message: "Board updated successfully." };
            } catch (e) {
                console.error("updateFirebaseBoard: Error updating game state:", e);
                return { success: false, message: e.message || "Unknown error updating board." };
            }
        }

        function listenToFirebaseGame(gameId, callback) {
            console.log("listenToFirebaseGame: Setting up listener for gameId:", gameId);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            return onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    console.log("listenToFirebaseGame: Received update for gameId:", gameId, docSnap.data());
                    callback(docSnap.data());
                } else {
                    console.error("listenToFirebaseGame: Game document no longer exists for gameId:", gameId);
                    alert("The game you were in no longer exists. Returning to lobby.");
                    window.closeWinnerModal();
                    window.showMultiplayerLobby();
                }
            }, (error) => {
                console.error("listenToFirebaseGame: Error listening to game:", error);
                alert("There was an error syncing with the game. Please refresh the page.");
            });
        }

        async function getAvailableGames() {
            console.log("getAvailableGames: Fetching available games...");
            const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
            const q = query(gamesCollectionRef, where("status", "==", "waiting"), limit(10));
            try {
                const querySnapshot = await getDocs(q);
                const availableGames = [];
                querySnapshot.forEach((doc) => {
                    availableGames.push(doc.data().gameId);
                });
                console.log("getAvailableGames: Found available games:", availableGames);
                return availableGames;
            } catch (e) {
                console.error("getAvailableGames: Error fetching available games:", e);
                throw e;
            }
        }


        // --- UI Control Functions (exposed to window) ---
        window.showDifficultySelection = function() {
            initialSetup.classList.add('hidden');
            multiplayerLobby.classList.add('hidden');
            difficultySelection.classList.remove('hidden');
        };

        window.showMultiplayerLobby = function() {
            initialSetup.classList.add('hidden');
            difficultySelection.classList.add('hidden');
            multiplayerLobby.classList.remove('hidden');
            window.refreshAvailableGames();
        };

        window.startGame = function(mode, difficulty = null) {
            gameMode = mode;
            computerDifficulty = difficulty;
            initialSetup.classList.add('hidden');
            multiplayerLobby.classList.add('hidden');
            difficultySelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');

            // Always render board HTML layout when starting any game mode
            renderBoardHtmlLayout();

            if (gameMode === 'pvp' || gameMode === 'pvc') {
                window.resetGame(); // Initialize game state for single-player/PvP
            } else { // Multiplayer
                // Game ID is displayed on the game screen.
                // The board data will be loaded via the Firebase listener in loadGameFromFirebase.
                gameDisplayIdInGame.textContent = currentGameId ? currentGameId : 'N/A';
            }
            // Ensure the game ID is set on the game screen, regardless of when the board loads.
            gameDisplayIdInGame.textContent = currentGameId ? currentGameId : 'N/A';
        };

        window.closeWinnerModal = function() {
            winnerModal.style.display = 'none';
            gameContainer.classList.add('hidden');
            if (gameMode === 'multiplayer') {
                window.showMultiplayerLobby();
            } else {
                initialSetup.classList.remove('hidden');
            }
        };

        // --- Multiplayer Lobby Functions (exposed to window) ---

        window.createGame = async function() {
            const currentUserId = auth.currentUser?.uid;
            if (!currentUserId) {
                console.error("createGame: auth.currentUser.uid is null. Authentication might not be complete yet.");
                alert("Authentication is not complete. Please wait for 'Authenticated' status to appear and the buttons to enable.");
                return;
            }
            console.log("createGame: Attempting to create game. Current User UID:", currentUserId);

            const gameId = generateGameId();
            displayGameId.textContent = gameId; // Update lobby game ID display
            yourColorElement.textContent = "Black (Player 1)";
            playerColor = 'black';
            currentGameId = gameId; // Set currentGameId here for use in startGame and listener

            try {
                const result = await createFirebaseGame(gameId, currentUserId);
                if (result.success) {
                    alert(`Game created! Share this link with a friend:\n${window.location.origin}${window.location.pathname}?gameId=${gameId}`);

                    // Setup listener before transitioning, so board gets data immediately
                    unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                        loadGameFromFirebase(gameData); // This will parse the board and update display

                        if (gameData.status === 'playing' && gameData.players.length === 2) {
                            multiplayerLobby.classList.add('hidden');
                            gameContainer.classList.remove('hidden');
                            gameDisplayIdInGame.textContent = currentGameId; // Update game ID on game screen
                        } else if (gameData.status === 'finished') {
                            endGame();
                        }
                    });
                    currentGameInfo.classList.remove('hidden');
                    window.startGame('multiplayer'); // Transition to game view (board will be populated by listener)
                } else {
                    alert(`Failed to create game: ${result.message}`);
                }
            } catch (error) {
                console.error("Error creating game:", error);
                alert(`Failed to create game: ${error.message}. Please check console for details and Firebase rules.`);
            }
        };

        window.joinGame = async function() {
            const currentUserId = auth.currentUser?.uid;
            if (!currentUserId) {
                console.error("joinGame: auth.currentUser.uid is null. Authentication might not be complete yet.");
                alert("Authentication is not complete. Please wait for 'Authenticated' status to appear and try again.");
                return;
            }
            console.log("joinGame: Attempting to join game. Current User UID:", currentUserId);

            const gameId = gameIdInput.value.trim();
            if (!gameId) {
                alert("Please enter a Game ID.");
                return;
            }

            try {
                const result = await joinFirebaseGame(gameId, currentUserId);
                if (result.success) {
                    displayGameId.textContent = gameId; // Update lobby game ID display
                    yourColorElement.textContent = "White (Player 2)";
                    playerColor = 'white';
                    currentGameId = gameId; // Set currentGameId here

                    // Setup listener before transitioning, so board gets data immediately
                    unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                        loadGameFromFirebase(gameData); // This will parse the board and update display
                        if (gameData.status === 'finished') {
                            endGame();
                        }
                    });
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    currentGameInfo.classList.remove('hidden');
                    window.startGame('multiplayer'); // Transition to game view (board will be populated by listener)
                } else {
                    alert(`Failed to join game: ${result.message}`);
                }
            } catch (error) {
                console.error("Error joining game:", error);
                alert(`Failed to join game: ${error.message}. Make sure the ID is correct and the game is not full.`);
            }
        };

        window.joinGameFromUrl = async function(gameId) {
            const currentUserId = auth.currentUser?.uid;
            if (!currentUserId) {
                return; // Let onAuthStateChanged retry
            }
            console.log(`joinGameFromUrl: Attempting to join game from URL: ${gameId}. Current User UID: ${currentUserId}`);

            try {
                const result = await joinFirebaseGame(gameId, currentUserId);
                if (result.success) {
                    initialSetup.classList.add('hidden');
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');

                    displayGameId.textContent = gameId; // Update lobby game ID display
                    yourColorElement.textContent = "White (Player 2)";
                    playerColor = 'white';
                    currentGameId = gameId; // Set currentGameId here

                    // Setup listener before transitioning, so board gets data immediately
                    unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                        loadGameFromFirebase(gameData); // This will parse the board and update display
                        if (gameData.status === 'finished') {
                            endGame();
                        }
                    });
                    currentGameInfo.classList.remove('hidden');
                    window.startGame('multiplayer'); // Transition to game view (board will be populated by listener)
                } else {
                    // Show an alert with the specific reason why joining from URL failed
                    alert(`Could not join game from link: ${result.message}. Please try creating/joining manually.`);
                    initialSetup.classList.remove('hidden'); // Go back to the initial setup if joining fails
                }
            } catch (error) {
                console.error("Error joining game from URL:", error);
                alert(`Could not join game from link: ${error.message}. Please try creating/joining manually.`);
                initialSetup.classList.remove('hidden');
            }
        };


        window.generateGameId = function() {
            return Math.random().toString(36).substring(2, 9).toUpperCase();
        };

        window.refreshAvailableGames = async function() {
            const currentUserId = auth.currentUser?.uid;
            if (!currentUserId) {
                availableGamesDiv.innerHTML = 'Please wait for authentication to complete.';
                return;
            }
            availableGamesDiv.innerHTML = 'Loading games...';
            try {
                const games = await getAvailableGames();
                availableGamesDiv.innerHTML = games.length > 0 ? '' : 'No games available.';
                games.forEach(gameId => {
                    const button = document.createElement('button');
                    button.textContent = gameId;
                    button.onclick = () => {
                        gameIdInput.value = gameId;
                        window.joinGame();
                    };
                    availableGamesDiv.appendChild(button);
                });
            }
            catch (error) {
                console.error("Error refreshing available games:", error);
                availableGamesDiv.innerHTML = 'Failed to load games. Please refresh.';
            }
        };

        window.leaveGame = function() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame();
            }
            currentGameId = null;
            playerColor = null;
            gameContainer.classList.add('hidden');
            currentGameInfo.classList.add('hidden');
            gameIdInput.value = '';
            window.showMultiplayerLobby();
        };

        // New function to leave the game screen and go back to the lobby
        window.leaveGameFromInGame = function() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame(); // Stop listening to this game
            }
            // Consider updating the Firebase game status here (e.g., 'abandoned') if you want to
            // mark the game as no longer active in Firestore. For simplicity, we're just leaving locally.

            currentGameId = null; // Clear current game ID
            playerColor = null; // Clear player color
            gameContainer.classList.add('hidden'); // Hide game board
            window.showMultiplayerLobby(); // Show the multiplayer lobby
        };

        window.copyGameLink = function() {
            if (currentGameId) {
                const gameLink = `${window.location.origin}${window.location.pathname}?gameId=${currentGameId}`;
                navigator.clipboard.writeText(gameLink)
                    .then(() => alert("Game link copied to clipboard! Share it with a friend."))
                    .catch(err => console.error("Could not copy text: ", err));
            }
        };

        // This function updates the local game state (board, current player etc.)
        // based on the data received from Firebase. It is called by the onSnapshot listener.
        function loadGameFromFirebase(gameData) {
            // Parse the board from JSON string back to 2D array
            board = JSON.parse(gameData.board);
            currentPlayer = gameData.currentPlayer;
            if (gameData.players && gameData.players.length > 0 && auth.currentUser?.uid) {
                const selfPlayer = gameData.players.find(p => p.uid === auth.currentUser.uid);
                if (selfPlayer) {
                    playerColor = selfPlayer.color;
                    yourColorElement.textContent = `${selfPlayer.color.charAt(0).toUpperCase() + selfPlayer.color.slice(1)} (Player ${selfPlayer.color === 'black' ? '1' : '2'})`;
                }
            }
            possibleMoves = getPossibleMoves(currentPlayer);
            updateBoardDisplay(); // Update pieces on the already rendered HTML board
            updateTurnDisplay();
            updateScoreDisplay();
            // Ensure game ID is displayed on the game screen
            if (gameMode === 'multiplayer' && currentGameId) {
                gameDisplayIdInGame.textContent = currentGameId;
            } else {
                gameDisplayIdInGame.textContent = 'N/A'; // For single player, or if gameId isn't set yet
            }
            console.log("Game data loaded from Firebase and display updated."); // Debug
        }


        // --- Board Management Functions ---
        function initializeBoard() {
            // Reset the internal board array and current player for single-player/PvP
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            board[3][3] = 'white';
            board[4][4] = 'white';
            board[3][4] = 'black';
            board[4][3] = 'black';
            currentPlayer = 'black';
        }

        // Function to render the empty Othello grid HTML layout (called only once when game container is shown)
        function renderBoardHtmlLayout() {
            if (!boardHtmlRendered) {
                boardElement.innerHTML = ''; // Clear any existing HTML
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.addEventListener('click', window.handleMove); // Attach event listener
                        boardElement.appendChild(cell);
                    }
                }
                boardHtmlRendered = true;
                console.log("Board HTML layout rendered for the first time."); // Debug
            }
        }

        // This function updates the visual representation of the pieces on the existing HTML board.
        function updateBoardDisplay() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.innerHTML = ''; // Clear current piece (just the piece, not the cell HTML)

                const pieceValue = board[row][col]; // Use the global `board` state
                if (pieceValue) {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('piece', pieceValue); // Add 'black' or 'white' class

                    // Check if the piece is in a corner
                    const isCorner = (row === 0 && col === 0) || (row === 0 && col === 7) ||
                                     (row === 7 && col === 0) || (row === 7 && col === 7);

                    if (isCorner) {
                        pieceElement.classList.add('corner-locked'); // Add special class for corner piece
                    }

                    cell.appendChild(pieceElement);
                }
                cell.classList.remove('possible-move', 'white');

                if (gameMode !== 'multiplayer' || (gameMode === 'multiplayer' && currentPlayer === playerColor)) {
                     if (possibleMoves.some(move => move.row === row && move.col === col)) {
                        cell.classList.add('possible-move');
                        if (currentPlayer === 'white') {
                            cell.classList.add('white');
                        }
                    }
                }
            });
            console.log("Board pieces display updated."); // Debug
        }

        function updateTurnDisplay() {
            let turnText = `${currentPlayer === 'black' ? 'Black' : 'White'}'s Turn`;
            if (gameMode === 'multiplayer' && currentPlayer !== playerColor) {
                turnText += " (Opponent's Turn)";
            } else if (gameMode === 'multiplayer' && currentPlayer === playerColor) {
                 turnText += " (Your Turn)";
            }
            turnElement.textContent = turnText;
        }

        function updateScoreDisplay() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }
            scoreElement.textContent = `Black: ${blackCount}, White: ${whiteCount}`;
        }

        // --- Game Logic Functions ---
        function getOpponent(player) {
            return player === 'black' ? 'white' : 'black';
        }

        function isValidMove(row, col, player, currentBoard) {
            if (row < 0 || row > 7 || col < 0 || col > 7 || currentBoard[row][col]) {
                return false;
            }
            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === opponent) {
                    foundOpponent = true;
                    r += dr;
                    c += dc;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === player) {
                    return true;
                }
            }
            return false;
        }

        function getPossibleMoves(player, currentBoard = board) {
            const moves = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (isValidMove(i, j, player, currentBoard)) {
                        moves.push({ row: i, col: j });
                    }
                }
            }
            return moves;
        }

        function flipPieces(row, col, player, currentBoard) {
            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            let piecesFlipped = 0;

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const piecesToFlipInDirection = [];
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === opponent) {
                    foundOpponent = true;
                    piecesToFlipInDirection.push({ row: r, col: c });
                    r += dr;
                    c += dc;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === player) {
                    piecesToFlipInDirection.forEach(p => {
                        currentBoard[p.row][p.col] = player;
                        piecesFlipped++;
                    });
                }
            }
            return piecesFlipped;
        }

        // --- Main Game Flow Handler (exposed to window) ---
        window.handleMove = async function(event) {
            if (gameMode === 'multiplayer' && (currentPlayer !== playerColor || !currentGameId)) {
                if (gameMode === 'multiplayer' && !currentGameId) {
                    console.warn("Game not joined. Button clicked before game setup complete.");
                } else if (gameMode === 'multiplayer' && currentPlayer !== playerColor) {
                    alert("It's not your turn.");
                }
                return;
            }

            const cell = event.target.closest('.cell');
            if (!cell || !cell.classList.contains('possible-move')) {
                return;
            }

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            const tempBoard = getDeepCopy(board);
            tempBoard[row][col] = currentPlayer;
            flipPieces(row, col, currentPlayer, tempBoard);

            let nextPlayerToMove = getOpponent(currentPlayer);
            let possibleMovesForNextPlayer = getPossibleMoves(nextPlayerToMove, tempBoard);

            let gameEndStatus = 'playing';
            let currentAlertMessage = null;

            if (possibleMovesForNextPlayer.length === 0) {
                const possibleMovesForCurrentPlayerAgain = getPossibleMoves(currentPlayer, tempBoard);
                if (possibleMovesForCurrentPlayerAgain.length > 0) {
                    currentAlertMessage = `${nextPlayerToMove.charAt(0).toUpperCase() + nextPlayerToMove.slice(1)} has no moves and skips their turn. It's ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn again!`;
                    nextPlayerToMove = currentPlayer;
                    possibleMovesForNextPlayer = possibleMovesForCurrentPlayerAgain;
                } else {
                    gameEndStatus = 'finished';
                }
            }

            board = tempBoard;
            currentPlayer = nextPlayerToMove;
            possibleMoves = possibleMovesForNextPlayer;

            if (gameEndStatus === 'finished') {
                if (gameMode === 'multiplayer' && currentGameId) {
                     await updateFirebaseBoard(currentGameId, board, currentPlayer, 'finished');
                } else {
                     window.endGame();
                }
            } else {
                updateBoardDisplay();
                updateTurnDisplay();
                updateScoreDisplay();

                if (currentAlertMessage) {
                    alert(currentAlertMessage);
                }

                if (gameMode === 'pvc' && currentPlayer === 'white') {
                    setTimeout(computerMove, getComputerDelay());
                } else if (gameMode === 'multiplayer' && currentGameId) {
                    await updateFirebaseBoard(currentGameId, board, currentPlayer, 'playing');
                }
            }
        };

        // --- Game End and Reset Functions (exposed to window) ---
        window.endGame = function() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }

            let winnerMessageText = '';
            if (blackCount > whiteCount) {
                winnerMessageText = 'Black wins!';
            } else if (whiteCount > blackCount) {
                winnerMessageText = 'White wins!';
            } else {
                winnerMessageText = 'It\'s a Draw!';
            }

            winnerMessage.textContent = winnerMessageText;
            finalScoresElement.textContent = `Black: ${blackCount}, White: ${whiteCount}`;
            window.showWinnerModal();
        };

        window.showWinnerModal = function() {
            winnerModal.style.display = 'flex';
        };

        window.resetGame = function() {
            if (gameMode === 'multiplayer') {
                alert("To reset a multiplayer game, please leave the current game from the lobby and create/join a new one.");
                return;
            }
            initializeBoard();
            renderBoardHtmlLayout(); // Ensure HTML is created for single player
            updateBoardDisplay(); // Populate with initial pieces
            updateTurnDisplay();
            updateScoreDisplay();
            possibleMoves = getPossibleMoves(currentPlayer);
            updateBoardDisplay(); // Re-highlight possible moves
            if (gameMode === 'pvc' && currentPlayer === 'white') {
                setTimeout(computerMove, getComputerDelay());
            }
        };

        // --- Rules and Tips Expander (exposed to window) ---
        window.toggleRules = function() {
            rulesContent.classList.toggle('expanded');
            if (rulesContent.classList.contains('expanded')) {
                rulesToggleButton.textContent = "Hide Rules & Tips";
            } else {
                rulesToggleButton.textContent = "Show Rules & Tips";
            }
        };


        // --- Computer AI Logic (internal to module, called by handleMove) ---
        function getScoreForBoard(currentBoard, player) {
            let playerScore = 0;
            let opponentScore = 0;
            const opponent = getOpponent(player);

            const WEIGHTS = [
                [100, -20, 10, 5, 5, 10, -20, 100],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [10, -2, 1, 1, 1, 1, -2, 10],
                [5, -2, 1, 1, 1, 1, -2, 5],
                [5, -2, 1, 1, 1, 1, -2, 5],
                [10, -2, 1, 1, 1, 1, -2, 10],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [100, -20, 10, 5, 5, 10, -20, 100]
            ];

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (currentBoard[i][j] === player) {
                        playerScore += WEIGHTS[i][j];
                    } else if (currentBoard[i][j] === opponent) {
                        opponentScore += WEIGHTS[i][j];
                    }
                }
            }
            return playerScore - opponentScore;
        }

        function getDeepCopy(boardArray) {
            return boardArray.map(row => [...row]);
        }

        function getComputerDelay() {
            switch (computerDifficulty) {
                case 'easy': return 1500;
                case 'medium': return 1000;
                case 'hard': return 700;
                default: return 1000;
            }
        }

        function computerMove() {
            if (gameMode !== 'pvc' || currentPlayer !== 'white') {
                return;
            }

            const moves = getPossibleMoves('white');
            if (moves.length === 0) {
                return;
            }

            let chosenMove = null;

            switch (computerDifficulty) {
                case 'easy':
                    chosenMove = moves[Math.floor(Math.random() * moves.length)];
                    break;
                case 'medium':
                    chosenMove = findBestMoveMedium(moves, 'white');
                    break;
                case 'hard':
                    chosenMove = findBestMoveMinimax(board, 'white', 3).move;
                    break;
                default:
                    chosenMove = moves[0];
            }

            if (chosenMove) {
                const cellElement = boardElement.querySelector(`[data-row="${chosenMove.row}"][data-col="${chosenMove.col}"]`);
                if (cellElement) {
                    window.handleMove({ target: cellElement });
                }
            }
        }

        function findBestMoveMedium(possibleMoves, player) {
            let bestMove = null;
            let maxFlipped = -1;

            const corners = [
                {row: 0, col: 0}, {row: 0, col: 7},
                {row: 7, col: 0}, {row: 7, col: 7}
            ];

            for (const move of possibleMoves) {
                if (corners.some(corner => corner.row === move.row && corner.col === move.col)) {
                    return move;
                }
            }

            for (const move of possibleMoves) {
                const tempBoard = getDeepCopy(board);
                tempBoard[move.row][move.col] = player;
                const flippedCount = flipPieces(move.row, move.col, player, tempBoard);

                if (flippedCount > maxFlipped) {
                    maxFlipped = flippedCount;
                    bestMove = move;
                }
            }
            return bestMove || possibleMoves[0];
        }

        function minimax(currentBoardState, depth, maximizingPlayer, player) {
            const opponent = getOpponent(player);

            if (depth === 0 || (getPossibleMoves(player, currentBoardState).length === 0 && getPossibleMoves(opponent, currentBoardState).length === 0)) {
                return { score: getScoreForBoard(currentBoardState, player) };
            }

            const currentPlayerInMinimax = maximizingPlayer ? player : opponent;
            const moves = getPossibleMoves(currentPlayerInMinimax, currentBoardState);

            if (moves.length === 0) {
                return minimax(currentBoardState, depth - 1, !maximizingPlayer, player);
            }

            if (maximizingPlayer) {
                let bestScore = -Infinity;
                let bestMove = null;

                for (const move of moves) {
                    const newBoard = getDeepCopy(currentBoardState);
                    newBoard[move.row][move.col] = currentPlayerInMinimax;
                    flipPieces(move.row, move.col, currentPlayerInMinimax, newBoard);

                    const score = minimax(newBoard, depth - 1, false, player).score;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return { score: bestScore, move: bestMove };
            } else {
                let bestScore = Infinity;
                let bestMove = null;

                for (const move of moves) {
                    const newBoard = getDeepCopy(currentBoardState);
                    newBoard[move.row][move.col] = currentPlayerInMinimax;
                    flipPieces(newBoard, move.row, move.col, currentPlayerInMinimax);
                    flipPieces(move.row, move.col, currentPlayerInMinimax, newBoard);

                    const score = minimax(newBoard, depth - 1, true, player).score;
                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return { score: bestScore, move: bestMove };
            }
        }

        function findBestMoveMinimax(currentBoard, player, depth) {
            const result = minimax(currentBoard, depth, true, player);
            return result;
        }

    </script>
</body>
</html>
