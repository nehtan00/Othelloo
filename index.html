<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Multiplayer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;700&display=swap" rel="stylesheet">
    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";

        // Your Firebase configuration (provided by the user) - declared only once.
        const firebaseConfig = {
          apiKey: "AIzaSyAUA91LXtcccAxl9OADnsYQwy1NPqjQgCA",
          authDomain: "othelloo-f8fac.firebaseapp.com",
          projectId: "othelloo-f8fac",
          storageBucket: "othelloo-f8fac.firebasestorage.app",
          messagingSenderId: "918267777112",
          appId: "1:918267777112:web:2c14924573793129573a2d",
          measurementId: "G-5RVK6DT5W0"
        };

        // Determine the appId to be used for Firestore paths.
        // For a self-contained file like this on GitHub Pages, we can use projectId from firebaseConfig.
        // The __app_id variable is typically for Canvas environments that inject it.
        const appId = firebaseConfig.projectId; // Using projectId as the application ID for Firestore paths

        // Initialize Firebase app
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        setLogLevel('Debug'); // Enable Firestore debug logging for console output

        // Make Firebase instances and appId globally accessible for other game functions
        window.db = db;
        window.auth = auth;
        window.appId = appId;

        // Get references to the multiplayer buttons to enable/disable them
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const refreshGamesButton = document.getElementById('refresh-games-button');


        // Firebase Anonymous Authentication
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log("Firebase authenticated:", user.uid);
                window.currentUserUid = user.uid; // Store current user's UID globally
                document.getElementById('auth-status').textContent = `Authenticated: ${user.uid.substring(0, 8)}...`;
                // Enable multiplayer buttons once authenticated
                if (createGameButton) createGameButton.disabled = false;
                if (joinGameButton) joinGameButton.disabled = false;
                if (refreshGamesButton) refreshGamesButton.disabled = false;


                // Check if a game ID is in the URL to auto-join
                const urlParams = new URLSearchParams(window.location.search);
                const gameIdFromUrl = urlParams.get('gameId');
                if (gameIdFromUrl) {
                    document.getElementById('game-id-input').value = gameIdFromUrl; // Pre-fill input
                    joinGameFromUrl(gameIdFromUrl); // Attempt to join
                } else {
                    // If no gameId in URL, show the initial game type selection
                    document.getElementById('initial-setup').classList.remove('hidden');
                }
            } else {
                console.log("Firebase not authenticated. Signing in anonymously...");
                // Disable multiplayer buttons if not authenticated
                if (createGameButton) createGameButton.disabled = true;
                if (joinGameButton) joinGameButton.disabled = true;
                if (refreshGamesButton) refreshGamesButton.disabled = true;

                document.getElementById('auth-status').textContent = `Authenticating...`;
                signInAnonymously(auth).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                    document.getElementById('auth-status').textContent = `Authentication failed: ${error.message}. Please refresh the page.`;
                });
            }
        });

        // Firebase Interaction Functions (made globally accessible)
        window.createFirebaseGame = async (gameId, player1Uid) => {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const initialBoard = Array(8).fill(null).map(() => Array(8).fill(null));
            initialBoard[3][3] = 'white';
            initialBoard[4][4] = 'white';
            initialBoard[3][4] = 'black';
            initialBoard[4][3] = 'black';

            const gameData = {
                gameId: gameId,
                players: [{uid: player1Uid, color: 'black'}], // Creator is Player 1 (Black)
                board: initialBoard,
                currentPlayer: 'black',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                lastMoveTimestamp: Date.now()
            };
            await setDoc(gameRef, gameData);
            console.log("Game created in Firestore:", gameId);
        };

        window.joinFirebaseGame = async (gameId, player2Uid) => {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const gameSnap = await getDoc(gameRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                // Check if there's only one player and it's not the joining player
                if (gameData.players.length === 1 && gameData.players[0].uid !== player2Uid) {
                    await updateDoc(gameRef, {
                        players: arrayUnion({uid: player2Uid, color: 'white'}), // Add Player 2 (White)
                        status: 'playing' // Change game status to playing
                    });
                    console.log("Joined game in Firestore:", gameId);
                    return true;
                } else if (gameData.players.some(p => p.uid === player2Uid)) {
                     console.log("Rejoining existing game:", gameId);
                     return true; // Already in the game, just rejoining
                } else if (gameData.players.length === 2) {
                    alert("This game is already full.");
                    return false;
                }
            } else {
                alert("Game ID does not exist.");
                return false;
            }
        };

        window.updateFirebaseBoard = async (gameId, newBoard, nextPlayer, newStatus) => {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            await updateDoc(gameRef, {
                board: newBoard,
                currentPlayer: nextPlayer,
                status: newStatus,
                lastMoveTimestamp: Date.now() // Update timestamp on every move
            });
        };

        window.listenToFirebaseGame = (gameId, callback) => {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            // Set up a real-time listener for game changes
            return onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    callback(docSnap.data()); // Pass the updated game data to the callback
                } else {
                    console.error("Game document no longer exists!");
                    alert("The game you were in no longer exists. Returning to lobby.");
                    closeWinnerModal(); // Force close if game disappears
                    // Consider also leaving the lobby if the game doesn't exist.
                    showMultiplayerLobby();
                }
            }, (error) => {
                console.error("Error listening to game:", error);
                alert("There was an error syncing with the game. Please refresh the page.");
            });
        };

        window.getAvailableGames = async () => {
            const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
            // Query for games that are in 'waiting' status and limit to 10 for display
            const q = query(gamesCollectionRef, where("status", "==", "waiting"), limit(10));
            const querySnapshot = await getDocs(q);
            const availableGames = [];
            querySnapshot.forEach((doc) => {
                availableGames.push(doc.data().gameId);
            });
            return availableGames;
        };
    </script>
    <style>
        body {
            font-family: 'Google Sans', sans-serif;
            background-color: #f0e6d2; /* Light earthy background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column; /* Stack the selection and game */
        }

        .auth-status {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: #e0c8a9;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #5e503f;
            z-index: 100;
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center; /* Center horizontally */
            align-items: center;   /* Center vertically */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto; /* Center horizontally and vertically */
            padding: 30px;
            border: 1px solid #888;
            width: 60%; /* Responsive width */
            max-width: 400px; /* Max width for larger screens */
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            color: #5e503f; /* Earthy text color */
            font-size: 1.2em;
        }

        .modal-content h3 {
            margin-top: 0;
            color: #333;
            font-weight: 700;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .selection-container {
            background-color: #a08e79; /* Medium earthy tone */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .selection-container h2 {
            color: #5e503f; /* Earthy text color */
            margin-bottom: 15px;
        }

        .selection-container button, .difficulty-container button, .info button,
        .lobby-controls button {
            font-family: 'Google Sans', sans-serif;
            background-color: #c6b8a9; /* Lighter earthy tone */
            color: #5e503f; /* Earthy text color */
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            margin: 5px;
            outline: none; /* Remove outline on focus */
        }

        .selection-container button:hover, .difficulty-container button:hover, .info button:hover,
        .lobby-controls button:hover {
            background-color: #b0a194; /* Slightly darker hover */
            transform: translateY(-2px); /* Subtle lift on hover */
        }
        .selection-container button:active, .difficulty-container button:active, .info button:active,
        .lobby-controls button:active {
            transform: translateY(0); /* Press down on click */
        }

        .lobby-controls button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .difficulty-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .difficulty-container h3 {
            color: #5e503f;
            margin-bottom: 10px;
        }

        .lobby-container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .lobby-container h2, .lobby-container h3 {
            color: #5e503f;
        }

        .lobby-controls input[type="text"] {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #776e65;
            margin-right: 10px;
            font-family: 'Google Sans', sans-serif;
            font-size: 16px;
            background-color: #f9f9f9;
            color: #333;
        }

        .available-games-list {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #776e65;
            border-radius: 5px;
            background-color: #e0c8a9;
            padding: 10px;
        }
        .available-games-list button {
            display: block;
            width: calc(100% - 10px);
            margin: 5px auto;
            text-align: center;
            padding: 8px;
            background-color: #c6b8a9;
            color: #5e503f;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .available-games-list button:hover {
            background-color: #b0a194;
        }

        .current-game-info {
            margin-top: 20px;
            color: #5e503f;
            font-size: 1.1em;
        }


        .container {
            background-color: #a08e79;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background-color: #776e65; /* Darker earthy tone for grid lines */
            border-radius: 4px;
        }

        .cell {
            background-color: #c6b8a9; /* Lighter earthy tone for cells */
            width: 60px;
            height: 60px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .cell:hover {
            filter: brightness(1.1);
        }

        .piece {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
        }

        .piece.black {
            background-color: #333;
        }

        .piece.white {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
        }

        .cell.possible-move {
            background-color: #b0a194; /* Slightly darker hover for possible moves */
        }

        .cell.possible-move::before {
            content: '';
            display: block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: rgba(51, 51, 51, 0.6); /* Indicate possible black move */
            transition: background-color 0.2s ease-in-out;
        }

        .cell.possible-move.white::before {
            background-color: rgba(249, 249, 249, 0.6); /* Indicate possible white move */
            border: 1px solid rgba(204, 204, 204, 0.6);
        }

        .info {
            margin-top: 20px;
            text-align: center;
            color: #5e503f; /* Earthy text color */
        }

        .info p {
            margin: 5px 0;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="auth-status" id="auth-status">Authenticating...</div>

    <div class="modal" id="winner-modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeWinnerModal()">&times;</span>
            <p id="winner-message"></p>
            <h3>Final Scores:</h3>
            <p id="final-scores"></p>
        </div>
    </div>

    <div class="selection-container hidden" id="initial-setup">
        <h2>Choose Game Type</h2>
        <button onclick="showMultiplayerLobby()">Multiplayer</button>
        <button onclick="showDifficultySelection()">Single Player (vs Computer)</button>
    </div>

    <div class="lobby-container hidden" id="multiplayer-lobby">
        <h2>Multiplayer Lobby</h2>
        <div class="lobby-controls">
            <input type="text" id="game-id-input" placeholder="Enter Game ID">
            <button id="create-game-button" onclick="createGame()" disabled>Create Game</button>
            <button id="join-game-button" onclick="joinGame()" disabled>Join Game</button>
        </div>
        <div class="available-games-list">
            <h3>Available Games:</h3>
            <div id="available-games">Loading games...</div>
            <button id="refresh-games-button" onclick="refreshAvailableGames()" disabled>Refresh List</button>
        </div>
        <div class="current-game-info hidden" id="current-game-info">
            <p>Game ID: <span id="display-game-id"></span></p>
            <p>Your Color: <span id="your-color"></span></p>
            <button onclick="leaveGame()">Leave Game</button>
            <button onclick="copyGameLink()">Copy Game Link</button>
        </div>
    </div>

    <div class="difficulty-container hidden" id="difficulty-selection">
        <h3>Choose Difficulty</h3>
        <button onclick="startGame('pvc', 'easy')">Easy</button>
        <button onclick="startGame('pvc', 'medium')">Medium</button>
        <button onclick="startGame('pvc', 'hard')">Hard</button>
    </div>

    <div class="container hidden" id="game-container">
        <div class="board" id="othello-board">
            </div>
        <div class="info">
            <p id="turn">Black's Turn</p>
            <p id="score">Black: 2, White: 2</p>
            <button onclick="resetGame()">Reset Game</button>
        </div>
    </div>

    <script>
        const initialSetup = document.getElementById('initial-setup');
        const multiplayerLobby = document.getElementById('multiplayer-lobby');
        const difficultySelection = document.getElementById('difficulty-selection');
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('othello-board');
        const turnElement = document.getElementById('turn');
        const scoreElement = document.getElementById('score');
        const winnerModal = document.getElementById('winner-modal');
        const winnerMessage = document.getElementById('winner-message');
        const finalScoresElement = document.getElementById('final-scores');
        const gameIdInput = document.getElementById('game-id-input');
        const availableGamesDiv = document.getElementById('available-games');
        const currentGameInfo = document.getElementById('current-game-info');
        const displayGameId = document.getElementById('display-game-id');
        const yourColorElement = document.getElementById('your-color');

        let board = Array(8).fill(null).map(() => Array(8).fill(null));
        let currentPlayer = 'black';
        let possibleMoves = [];
        let gameMode = null; // 'pvp', 'pvc', 'multiplayer'
        let computerDifficulty = null; // 'easy', 'medium', 'hard'
        let playerColor = null; // 'black' or 'white' for the current user in multiplayer
        let currentGameId = null; // The ID of the current multiplayer game
        let unsubscribeFromGame = null; // Function to unsubscribe from Firestore listener

        // Global variables from Firebase SDK import (set on window by the module script)
        // These are already initialized in the <script type="module"> block above
        const db = window.db;
        const auth = window.auth;
        const appId = window.appId; // This now correctly uses firebaseConfig.projectId
        const currentUserUid = window.currentUserUid; // This will be populated by onAuthStateChanged
        const createFirebaseGame = window.createFirebaseGame;
        const joinFirebaseGame = window.joinFirebaseGame;
        const updateFirebaseBoard = window.updateFirebaseBoard;
        const listenToFirebaseGame = window.listenToFirebaseGame;
        const getAvailableGames = window.getAvailableGames;


        // --- UI Control Functions ---
        function showDifficultySelection() {
            initialSetup.classList.add('hidden');
            multiplayerLobby.classList.add('hidden');
            difficultySelection.classList.remove('hidden');
        }

        function showMultiplayerLobby() {
            initialSetup.classList.add('hidden');
            difficultySelection.classList.add('hidden');
            multiplayerLobby.classList.remove('hidden');
            refreshAvailableGames(); // Load available games when entering lobby
        }

        function startGame(mode, difficulty = null) {
            gameMode = mode;
            computerDifficulty = difficulty;
            initialSetup.classList.add('hidden');
            multiplayerLobby.classList.add('hidden');
            difficultySelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            resetGame(); // Call resetGame to initialize and display the board
        }

        function closeWinnerModal() {
            winnerModal.style.display = 'none';
            // Return to initial setup or lobby after closing modal
            gameContainer.classList.add('hidden');
            if (gameMode === 'multiplayer') {
                showMultiplayerLobby();
            } else {
                initialSetup.classList.remove('hidden');
            }
        }

        // --- Multiplayer Lobby Functions ---

        async function createGame() {
            // Check if currentUserUid is available before proceeding
            if (!window.currentUserUid) {
                alert("Authentication is not complete. Please wait a moment for 'Authenticating...' status to change.");
                return;
            }
            const gameId = generateGameId();
            displayGameId.textContent = gameId;
            yourColorElement.textContent = "Black (Player 1)";
            playerColor = 'black'; // Set current user's color
            currentGameId = gameId; // Store the created game ID

            try {
                await createFirebaseGame(gameId, window.currentUserUid);
                alert(`Game created! Share this link with a friend:\n${window.location.origin}${window.location.pathname}?gameId=${gameId}`);

                // Listen for updates to this game (especially for a second player joining)
                unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                    // Update local game state based on Firestore
                    loadGameFromFirebase(gameData);

                    if (gameData.status === 'playing' && gameData.players.length === 2) {
                        // Game started, transition to game view if not already there
                        multiplayerLobby.classList.add('hidden');
                        gameContainer.classList.remove('hidden');
                        // The loadGameFromFirebase already updates board, turn, score displays
                    } else if (gameData.status === 'finished') {
                        endGame(); // Display winner modal
                    }
                });

                // Show game info and link to copy
                currentGameInfo.classList.remove('hidden');

            } catch (error) {
                console.error("Error creating game:", error);
                alert("Failed to create game. Please try again.");
            }
        }

        async function joinGame() {
            // Check if currentUserUid is available before proceeding
            if (!window.currentUserUid) {
                alert("Authentication is not complete. Please wait a moment for 'Authenticating...' status to change.");
                return;
            }
            const gameId = gameIdInput.value.trim();
            if (!gameId) {
                alert("Please enter a Game ID.");
                return;
            }

            try {
                const joined = await joinFirebaseGame(gameId, window.currentUserUid);
                if (joined) {
                    displayGameId.textContent = gameId;
                    yourColorElement.textContent = "White (Player 2)";
                    playerColor = 'white'; // Set current user's color
                    currentGameId = gameId; // Store the joined game ID

                    // Listen for updates to this game
                    unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                        loadGameFromFirebase(gameData); // Update local game state based on Firestore
                        if (gameData.status === 'finished') {
                            endGame(); // Display winner modal
                        }
                    });

                    // Hide lobby and show game container
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    currentGameInfo.classList.remove('hidden'); // Show game info
                }
            } catch (error) {
                console.error("Error joining game:", error);
                alert("Failed to join game. Make sure the ID is correct and the game is not full.");
            }
        }

        // Joins game if gameId is present in URL on page load
        async function joinGameFromUrl(gameId) {
            if (!window.currentUserUid) {
                // This function might be called before authentication completes.
                // `onAuthStateChanged` will re-call this once `currentUserUid` is set.
                return;
            }
            console.log(`Attempting to join game from URL: ${gameId}`);
            try {
                const joined = await joinFirebaseGame(gameId, window.currentUserUid);
                if (joined) {
                    // If successfully joined, navigate to game view
                    initialSetup.classList.add('hidden');
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');

                    displayGameId.textContent = gameId;
                    yourColorElement.textContent = "White (Player 2)"; // Default to white for joiner via URL
                    playerColor = 'white';
                    currentGameId = gameId;

                    unsubscribeFromGame = listenToFirebaseGame(gameId, (gameData) => {
                        loadGameFromFirebase(gameData); // Update local game state from Firestore
                        if (gameData.status === 'finished') {
                            endGame();
                        }
                    });
                    currentGameInfo.classList.remove('hidden');
                } else {
                    // If joining failed (e.g., game full or doesn't exist), return to initial setup
                    initialSetup.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error joining game from URL:", error);
                alert("Could not join game from link. It might be invalid or full. Please try creating/joining manually.");
                initialSetup.classList.remove('hidden');
            }
        }


        function generateGameId() {
            return Math.random().toString(36).substring(2, 9).toUpperCase(); // Simple 7-char ID
        }

        async function refreshAvailableGames() {
            if (!window.currentUserUid) {
                availableGamesDiv.innerHTML = 'Please wait for authentication to complete.';
                return;
            }
            availableGamesDiv.innerHTML = 'Loading games...'; // Show loading state
            try {
                const games = await getAvailableGames();
                availableGamesDiv.innerHTML = games.length > 0 ? '' : 'No games available.';
                games.forEach(gameId => {
                    const button = document.createElement('button');
                    button.textContent = gameId;
                    button.onclick = () => {
                        gameIdInput.value = gameId;
                        joinGame();
                    };
                    availableGamesDiv.appendChild(button);
                });
            } catch (error) {
                console.error("Error refreshing available games:", error);
                availableGamesDiv.innerHTML = 'Failed to load games. Please refresh.';
            }
        }

        function leaveGame() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame(); // Stop listening to Firestore
            }
            currentGameId = null;
            playerColor = null;
            gameContainer.classList.add('hidden');
            currentGameInfo.classList.add('hidden');
            gameIdInput.value = ''; // Clear the input field
            showMultiplayerLobby(); // Go back to lobby
        }

        function copyGameLink() {
            if (currentGameId) {
                const gameLink = `${window.location.origin}${window.location.pathname}?gameId=${currentGameId}`;
                navigator.clipboard.writeText(gameLink)
                    .then(() => alert("Game link copied to clipboard! Share it with a friend."))
                    .catch(err => console.error("Could not copy text: ", err));
            }
        }

        // This function updates the local game state (board, current player etc.)
        // based on the data received from Firebase.
        function loadGameFromFirebase(gameData) {
            board = gameData.board;
            currentPlayer = gameData.currentPlayer;
            // Ensure playerColor is correctly set for the client from gameData.players
            if (gameData.players && gameData.players.length > 0 && window.currentUserUid) {
                const selfPlayer = gameData.players.find(p => p.uid === window.currentUserUid);
                if (selfPlayer) {
                    playerColor = selfPlayer.color;
                    yourColorElement.textContent = `${selfPlayer.color.charAt(0).toUpperCase() + selfPlayer.color.slice(1)} (Player ${selfPlayer.color === 'black' ? '1' : '2'})`;
                }
            }
            possibleMoves = getPossibleMoves(currentPlayer); // Calculate possible moves for the received current player
            updateBoardDisplay();
            updateTurnDisplay();
            updateScoreDisplay();
        }


        // --- Board Management Functions ---
        function initializeBoard() {
            // Reset the board to its initial state
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            board[3][3] = 'white';
            board[4][4] = 'white';
            board[3][4] = 'black';
            board[4][3] = 'black';
            currentPlayer = 'black'; // Black always starts
        }

        function createBoard() {
            boardElement.innerHTML = ''; // Clear existing cells
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', handleMove); // Add event listener to each cell

                    const piece = board[i][j];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', piece);
                        cell.appendChild(pieceElement);
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        function updateBoardDisplay() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.innerHTML = ''; // Clear current piece

                const piece = board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('piece', piece);
                    cell.appendChild(pieceElement);
                }
                // Remove and re-add possible-move class for correct highlighting
                cell.classList.remove('possible-move', 'white');

                // Only highlight moves for the current local player's turn, or for all in PvP/PvC
                if (gameMode !== 'multiplayer' || (gameMode === 'multiplayer' && currentPlayer === playerColor)) {
                     if (possibleMoves.some(move => move.row === row && move.col === col)) {
                        cell.classList.add('possible-move');
                        if (currentPlayer === 'white') {
                            cell.classList.add('white'); // Apply white indicator for white's possible moves
                        }
                    }
                }
            });
        }

        function updateTurnDisplay() {
            let turnText = `${currentPlayer === 'black' ? 'Black' : 'White'}'s Turn`;
            if (gameMode === 'multiplayer' && currentPlayer !== playerColor) {
                turnText += " (Opponent's Turn)";
            } else if (gameMode === 'multiplayer' && currentPlayer === playerColor) {
                 turnText += " (Your Turn)";
            }
            turnElement.textContent = turnText;
        }

        function updateScoreDisplay() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }
            scoreElement.textContent = `Black: ${blackCount}, White: ${whiteCount}`;
        }

        // --- Game Logic Functions ---
        function getOpponent(player) {
            return player === 'black' ? 'white' : 'black';
        }

        function isValidMove(row, col, player, currentBoard) {
            // Check if the cell is within bounds and empty
            if (row < 0 || row > 7 || col < 0 || col > 7 || currentBoard[row][col]) {
                return false;
            }

            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1], // Horizontal and Vertical
                [-1, -1], [-1, 1], [1, -1], [1, 1]  // Diagonal
            ];

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                let foundOpponent = false;

                // Traverse in this direction as long as we find opponent's pieces
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === opponent) {
                    foundOpponent = true;
                    r += dr;
                    c += dc;
                }

                // If we found opponent pieces and then landed on one of our own, it's a valid flip direction
                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === player) {
                    return true; // At least one direction allows a flip
                }
            }

            return false;
        }

        function getPossibleMoves(player, currentBoard = board) {
            const moves = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (isValidMove(i, j, player, currentBoard)) {
                        moves.push({ row: i, col: j });
                    }
                }
            }
            return moves;
        }

        function flipPieces(row, col, player, currentBoard) {
            const opponent = getOpponent(player);
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            let piecesFlipped = 0; // Counter for AI heuristic

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const piecesToFlipInDirection = [];
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === opponent) {
                    foundOpponent = true;
                    piecesToFlipInDirection.push({ row: r, col: c });
                    r += dr;
                    c += dc;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && currentBoard[r][c] === player) {
                    piecesToFlipInDirection.forEach(p => {
                        currentBoard[p.row][p.col] = player;
                        piecesFlipped++;
                    });
                }
            }
            return piecesFlipped;
        }

        // --- Main Game Flow Handler ---
        async function handleMove(event) {
            // In multiplayer, only allow moves if it's your turn and you are the current player
            if (gameMode === 'multiplayer' && (currentPlayer !== playerColor || !currentGameId)) {
                if (gameMode === 'multiplayer' && !currentGameId) {
                    // Should not happen if buttons are disabled until authenticated
                    console.warn("Game not joined. Button clicked before game setup complete.");
                } else if (gameMode === 'multiplayer' && currentPlayer !== playerColor) {
                    alert("It's not your turn.");
                }
                return;
            }

            const cell = event.target.closest('.cell');
            if (!cell || !cell.classList.contains('possible-move')) {
                return; // Not a valid or highlighted move
            }

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Create a temporary board to simulate the move and check post-move state
            const tempBoard = getDeepCopy(board);
            tempBoard[row][col] = currentPlayer;
            flipPieces(row, col, currentPlayer, tempBoard);

            let nextPlayerToMove = getOpponent(currentPlayer);
            let possibleMovesForNextPlayer = getPossibleMoves(nextPlayerToMove, tempBoard);

            let gameEndStatus = 'playing';
            let currentAlertMessage = null;

            if (possibleMovesForNextPlayer.length === 0) {
                // The next player has no moves. Check if the current player has moves.
                const possibleMovesForCurrentPlayerAgain = getPossibleMoves(currentPlayer, tempBoard);
                if (possibleMovesForCurrentPlayerAgain.length > 0) {
                    // Current player (who just moved) gets another turn because the opponent has no moves
                    currentAlertMessage = `${nextPlayerToMove.charAt(0).toUpperCase() + nextPlayerToMove.slice(1)} has no moves and skips their turn. It's ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn again!`;
                    nextPlayerToMove = currentPlayer; // Stay on the same player
                    possibleMovesForNextPlayer = possibleMovesForCurrentPlayerAgain; // Update possible moves
                } else {
                    // Neither player has moves, game over
                    gameEndStatus = 'finished';
                }
            }

            // Update the actual game board state
            board = tempBoard;
            currentPlayer = nextPlayerToMove; // Set the new current player
            possibleMoves = possibleMovesForNextPlayer; // Update possible moves for the new current player

            // Handle turn progression and UI/Firebase updates
            if (gameEndStatus === 'finished') {
                if (gameMode === 'multiplayer' && currentGameId) {
                     await updateFirebaseBoard(currentGameId, board, currentPlayer, 'finished');
                } else { // Single player or multiplayer game just ended locally (before Firebase update)
                     endGame(); // Display winner modal
                }
            } else {
                // Update UI immediately
                updateBoardDisplay();
                updateTurnDisplay();
                updateScoreDisplay();

                if (currentAlertMessage) {
                    alert(currentAlertMessage);
                }

                // If it's PVC mode and it's the computer's turn, initiate AI move
                if (gameMode === 'pvc' && currentPlayer === 'white') {
                    setTimeout(computerMove, getComputerDelay());
                } else if (gameMode === 'multiplayer' && currentGameId) {
                    // For multiplayer, push the state to Firebase
                    await updateFirebaseBoard(currentGameId, board, currentPlayer, 'playing');
                }
            }
        }

        // --- Game End and Reset Functions ---
        function endGame() {
            let blackCount = 0;
            let whiteCount = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (board[i][j] === 'black') blackCount++;
                    else if (board[i][j] === 'white') whiteCount++;
                }
            }

            let winnerMessageText = '';
            if (blackCount > whiteCount) {
                winnerMessageText = 'Black wins!';
            } else if (whiteCount > blackCount) {
                winnerMessageText = 'White wins!';
            } else {
                winnerMessageText = 'It\'s a Draw!';
            }

            winnerMessage.textContent = winnerMessageText;
            finalScoresElement.textContent = `Black: ${blackCount}, White: ${whiteCount}`;
            showWinnerModal();
        }

        function showWinnerModal() {
            winnerModal.style.display = 'flex'; // Use flex to center
        }

        function resetGame() {
            if (gameMode === 'multiplayer') {
                // In multiplayer, reset is managed by Firebase updates.
                // A player should "leave" the game and create/join a new one.
                alert("To reset a multiplayer game, please leave the current game from the lobby and create/join a new one.");
                return;
            }
            initializeBoard(); // Resets the internal board array and current player
            createBoard(); // Recreates the HTML board elements
            updateTurnDisplay();
            updateScoreDisplay();
            possibleMoves = getPossibleMoves(currentPlayer); // Calculate initial possible moves
            updateBoardDisplay(); // Highlight initial moves
            if (gameMode === 'pvc' && currentPlayer === 'white') {
                setTimeout(computerMove, getComputerDelay());
            }
        }

        // --- Computer AI Logic ---

        // Simple heuristic to get the score for a given board state
        function getScoreForBoard(currentBoard, player) {
            let playerScore = 0;
            let opponentScore = 0;
            const opponent = getOpponent(player);

            // Weights for board positions (corners are valuable, edges less so, squares next to corners negative)
            const WEIGHTS = [
                [100, -20, 10, 5, 5, 10, -20, 100],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [10, -2, 1, 1, 1, 1, -2, 10],
                [5, -2, 1, 1, 1, 1, -2, 5],
                [5, -2, 1, 1, 1, 1, -2, 5],
                [10, -2, 1, 1, 1, 1, -2, 10],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [100, -20, 10, 5, 5, 10, -20, 100]
            ];

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (currentBoard[i][j] === player) {
                        playerScore += WEIGHTS[i][j];
                    } else if (currentBoard[i][j] === opponent) {
                        opponentScore += WEIGHTS[i][j];
                    }
                }
            }
            return playerScore - opponentScore;
        }

        // Helper to make a deep copy of the board
        function getDeepCopy(boardArray) {
            return boardArray.map(row => [...row]);
        }

        function getComputerDelay() {
            switch (computerDifficulty) {
                case 'easy': return 1500; // Slower, more noticeable AI turn
                case 'medium': return 1000;
                case 'hard': return 700; // Faster, more challenging AI
                default: return 1000;
            }
        }

        // AI Logic based on difficulty
        function computerMove() {
            if (gameMode !== 'pvc' || currentPlayer !== 'white') {
                return; // Only computer plays if it's PVC mode and it's white's turn
            }

            const moves = getPossibleMoves('white');
            if (moves.length === 0) {
                // If no moves, this means a skip already occurred or the game is over.
                // The handleMove logic already checks for skips and game end.
                return;
            }

            let chosenMove = null;

            switch (computerDifficulty) {
                case 'easy':
                    // Easy: Random move
                    chosenMove = moves[Math.floor(Math.random() * moves.length)];
                    break;
                case 'medium':
                    // Medium: Prioritize corners, then moves that flip the most pieces
                    chosenMove = findBestMoveMedium(moves, 'white');
                    break;
                case 'hard':
                    // Hard: Minimax with limited depth
                    // Depth of 3 for example. Higher depth is more intelligent but slower.
                    chosenMove = findBestMoveMinimax(board, 'white', 3).move;
                    break;
                default:
                    chosenMove = moves[0]; // Fallback
            }

            if (chosenMove) {
                // Simulate a click event on the chosen cell
                // This is important to trigger the handleMove function and all its side effects
                const cellElement = boardElement.querySelector(`[data-row="${chosenMove.row}"][data-col="${chosenMove.col}"]`);
                if (cellElement) {
                    cellElement.click();
                }
            }
        }

        function findBestMoveMedium(possibleMoves, player) {
            let bestMove = null;
            let maxFlipped = -1; // Track the maximum number of pieces flipped

            const corners = [
                {row: 0, col: 0}, {row: 0, col: 7},
                {row: 7, col: 0}, {row: 7, col: 7}
            ];

            // First, check for corners - always prioritize them
            for (const move of possibleMoves) {
                if (corners.some(corner => corner.row === move.row && corner.col === move.col)) {
                    return move; // Take the corner immediately
                }
            }

            // If no corners, find the move that flips the most pieces
            for (const move of possibleMoves) {
                const tempBoard = getDeepCopy(board); // Create a temporary board to simulate the move
                // Simulate placing the piece and flipping others
                tempBoard[move.row][move.col] = player;
                const flippedCount = flipPieces(move.row, move.col, player, tempBoard);

                if (flippedCount > maxFlipped) {
                    maxFlipped = flippedCount;
                    bestMove = move;
                }
            }
            return bestMove || possibleMoves[0]; // Fallback to the first available move if no pieces flipped (shouldn't happen with isValidMove)
        }

        // Minimax Algorithm (simplified for Othello)
        function minimax(currentBoardState, depth, maximizingPlayer, player) {
            const opponent = getOpponent(player);

            // Base case: if depth is 0 or game is over
            // A simple check for game over: no possible moves for either player
            if (depth === 0 || (getPossibleMoves(player, currentBoardState).length === 0 && getPossibleMoves(opponent, currentBoardState).length === 0)) {
                return { score: getScoreForBoard(currentBoardState, player) };
            }

            // Determine whose turn it is in the simulated game tree
            const currentPlayerInMinimax = maximizingPlayer ? player : opponent;
            const moves = getPossibleMoves(currentPlayerInMinimax, currentBoardState);

            // If no moves for the current player in minimax, simulate a skip
            if (moves.length === 0) {
                // Recursively call minimax for the next player's turn with reduced depth
                return minimax(currentBoardState, depth - 1, !maximizingPlayer, player);
            }

            if (maximizingPlayer) {
                let bestScore = -Infinity;
                let bestMove = null;

                for (const move of moves) {
                    const newBoard = getDeepCopy(currentBoardState);
                    newBoard[move.row][move.col] = currentPlayerInMinimax;
                    flipPieces(move.row, move.col, currentPlayerInMinimax, newBoard);

                    const score = minimax(newBoard, depth - 1, false, player).score; // Recursively call for minimizing player
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return { score: bestScore, move: bestMove };
            } else { // Minimizing player
                let bestScore = Infinity;
                let bestMove = null;

                for (const move of moves) {
                    const newBoard = getDeepCopy(currentBoardState);
                    newBoard[move.row][move.col] = currentPlayerInMinimax;
                    flipPieces(move.row, move.col, currentPlayerInMinimax, newBoard);

                    const score = minimax(newBoard, depth - 1, true, player).score; // Recursively call for maximizing player
                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return { score: bestScore, move: bestMove };
            }
        }

        function findBestMoveMinimax(currentBoard, player, depth) {
            // Initial call to minimax to find the best move for the 'player'
            const result = minimax(currentBoard, depth, true, player);
            return result; // Returns an object like {score: ..., move: {row: ..., col: ...}}
        }

    </script>
</body>
</html>
